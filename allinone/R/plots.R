# DATA
#' Geodata of Swiss municipalities, districts, cantons and lakes (2001)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2001-1-1. The data is made publicly available by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 60,271 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{\code{0} for all data points}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2001
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2001"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2002)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2002-1-1. The data is made publicly available by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 59,986 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{\code{0} for all data points}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2002
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2002"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2003)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2003-1-1. The data is made publicly available by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 59,783 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{\code{0} for all data points}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2003
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2003"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2004)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2004-1-1. The data is made publicly available by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 59,171 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{\code{0} for all data points}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2004
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2004"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2004)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2004-1-1. The data is made publicly available by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 59,171 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{\code{0} for all data points}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2004
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2004"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2005)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2005-1-1. The data is made publicly available by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 58,637 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{\code{0} for all data points}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2005
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2005"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2006)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2006-1-1. The data is made publicly available by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 58,598 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{\code{0} for all data points}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2006
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2006"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2007)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2007-1-1. The data is made publicly available by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 58,230 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{\code{0} for all data points}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2007
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2007"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2008)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2008-1-1. The data is made publicly available by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 58,180 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{\code{0} for all data points}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2008
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2008"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2009)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2009-1-1. The data is made publicly available by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 57,301 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{\code{0} for all data points}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2009
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2009"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2010)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2010-1-1 and 2010-31-12. The data is made publicly available
#'  by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 105,093 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{if \code{0}, the data point dates from 2010-1-1, else from 2010-31-12}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2010
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2010"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2011)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2011-1-1 and 2011-31-12. The data is made publicly available
#'  by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 92,762 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{if \code{0}, the data point dates from 2011-1-1, else from 2011-31-12}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2011
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2011"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2012)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2012-1-1 and 2012-31-12. The data is made publicly available
#'  by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 92,317 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{if \code{0}, the data point dates from 2012-1-1, else from 2012-31-12}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2012
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2012"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2013)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2013-1-1 and 2013-31-12. The data is made publicly available
#'  by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 171,307 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{if \code{0}, the data point dates from 2013-1-1, else from 2013-31-12}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2013
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2013"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2014)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2014-1-1 and 2014-31-12. The data is made publicly available
#'  by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 163,660 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{if \code{0}, the data point dates from 2014-1-1, else from 2014-31-12}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2014
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2014"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2015)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2015-1-1 and 2015-31-12. The data is made publicly available
#'  by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 162,650 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{if \code{0}, the data point dates from 2015-1-1, else from 2015-31-12}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2015
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2015"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2016)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2016-1-1 and 2016-31-12. The data is made publicly available
#'  by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 162,148 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{if \code{0}, the data point dates from 2016-1-1, else from 2016-31-12}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2016
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2016"

#' Geodata of Swiss municipalities, districts, cantons and lakes (2017)
#'
#'  A ggplot2-compatible data frame containing geodata of Swiss municipalities, districts,
#'  cantons and lakes as of 2017-1-1. The data is made publicly available
#'  by the \href{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}{Swiss Federal Statistical Office}.
#'  The data is scaled at ~1:2,000,000.
#'
#' @format A data frame with 80,453 rows and 10 variables:
#' \describe{
#'   \item{year}{year of geodata}
#'   \item{endofyear}{\code{0} for all data points}
#'   \item{long}{longitude of point}
#'   \item{lat}{latitude of point}
#'   \item{group}{if two adjacent points are in the same group, then they get connected}
#'   \item{type}{type of object point belongs to: \code{municipality}, \code{district}, \code{canton},
#'   \code{country}, \code{lake})}
#'   \item{id}{official identification number of object}
#'   \item{name}{name of object}
#'   \item{dis}{district object belongs to}
#'   \item{can}{canton object belongs to}}
#'
#' @name mapCH2017
#' @docType data
#' @author David Zumbach \email{david.zumbach@gfzb.ch}
#' @source Swiss Federal Statistical Office, GEOSTAT (last download 2017-09-07)
#' @references \url{https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html}
"mapCH2017"

# FUNCTION TO PLOT MUNICIPALITIES
#' Plot thematic municipality-level maps
#'
#' \code{mun.plot} offers the possbility to visualise Swiss municipality-level data on a map. The GitHub version
#'     of \code{RSwissMaps} comes with all available geodata (\code{2001-2017}). Hence, the \code{map.load} function
#'     is not part of this version. The function arguments make it easy to plot and save customised maps. The function
#'     \code{\link{mun.template}} provides templates for data collection.
#'
#' @param bfs_id a numeric vector with municipality identification numbers as used by the Swiss Federal
#'     Statistical Office corresponding to \code{data}. For templates, see: \code{\link{mun.template}}.
#' @param data a vector of data at municipality-level.
#' @param year a numeric value that indicates what map version to plot. Available with GitHub version of
#'     package: \code{2001-2017}
#' @param endofyear if \code{FALSE}, administrative divisions as of January 1 are used. If \code{TRUE},
#'     administrative divisions as by December 31 are plotted. End-of-year data is available for
#'     \code{year > 2010}.
#' @param cantons a numeric (canton identification numbers) or a character (two-letter abbreviations)
#'     vector to plot municipalities of selected cantons.
#' @param districts a numeric (district identification numbers) or a character (district names)
#'     vector to plot municipalities of selected districts.
#' @param municipalities a numeric (municipality identification numbers) or a character (municipality
#'     names) vector to plot selected municipalities.
#' @param lakes a numeric (lake identification numbers) or a character (lakes names) vector to
#'     plot selected lakes. If \code{"none"}, no lakes are plotted. If \code{"all"}, all
#'     \href{https://github.com/zumbov2/RSwissMaps/blob/master/lakes}{available lakes} are plotted.
#' @param boundaries a character vector naming the boundaries to map:\itemize{
#'   \item \code{"m"}: municipality boundaries (default)
#'   \item \code{"d"}: district boundaries
#'   \item \code{"c"}: cantonal boundaries
#'   \item \code{"n"}: national boundary}
#' @param boundaries_size a numeric vector that specifies the sizes of the corresponding elements in \code{boundaries}.
#' @param boundaries_color a character vector that specifies the colors of the corresponding elements
#'     in \code{boundaries}.
#' @param extrema if \code{"local"}, data of municipalities that are not selected by \code{cantons}, \code{districts}
#'     and/or \code{municipalities} is not considered in the color scaling process.
#' @param continuous set to \code{FALSE}, if \code{data} is non-continuous.
#' @param color_continuous a character vector with two elements to specifiy the plot color if \code{continuous =
#'     TRUE}. \code{color_continuous = c("low", "high")} resulting in a two color gradient from color
#'     \code{"low"} to color \code{"high"}.
#' @param color_discrete name of a RColorBrewer palette to specifiy the plot color if \code{continuous = FALSE}.
#'     See: \href{https://rpubs.com/flowertear/224344 }{RColorBrewer palettes}.
#' @param color_na a character string. color of districts with missing values.
#' @param title,subtitle,caption,legend_title text for titles and caption below the plot.
#' @param legend_position position of the legend: one of \code{"none"}, \code{"left"}, \code{"right"},
#'     \code{"bottom"}, \code{"top"})
#' @param save if \code{TRUE}, the map will be saved to disk.
#' @param filename file name to create on disk incl. image file format (".jpeg", ".png", ".tiff", etc.).
#' @param dpi plot resolution. Applies only to raster output types.
#' @param width,heigth,units plot size in units (\code{"in"}, \code{"cm"}, or \code{"mm"}). If not supplied, uses
#'     the size of current graphics device.
#' @examples
#'  # Generating sample data for 2016:
#'  dt <- mun.template(2016)
#'  for(i in 1:nrow(dt)){dt$values[i] <- sample(c(300:700), 1)/1000}
#'
#'  # Plotting sample data of 2016:
#'  mun.plot(dt$bfs_nr, dt$values, 2016)
#'
#'  # Plotting sample data for the canton of Aargau:
#'  mun.plot(dt$bfs_nr, dt$values, cantons = c("AG"), 2016,
#'  lakes = c("Hallwilersee"))
#' @export
mun.plot <- function(bfs_id, data, year, endofyear = FALSE,
                     cantons = NULL, districts = NULL, municipalities = NULL, lakes = "all",
                     boundaries = "m", boundaries_size = 0.1, boundaries_color = "white",
                     extrema = "global", continuous = TRUE,
                     color_continuous = c("#fee5d9", "#a50f15"), color_discrete = c("Reds"), color_na = "gray90",
                     title = NULL, subtitle = NULL, caption = NULL, legend_title = NULL, legend_position = "bottom",
                     save = FALSE, filename = "mun_plot.png", dpi = 300, width = NA, heigth = NA, units = "cm") {

  # Checking BFS_ID and data ------------------------
  if(missing(bfs_id)) stop("bfs_id is missing")
  if(missing(data)) stop("data is missing")
  if(length(bfs_id)!=length(data)) stop("inputs differ in length")

  # Loading map data based on YEAR and ENDOFYEAR ------------------------
  if(!is.logical(endofyear)) stop("endofyear: TRUE or FALSE needed")
  if(year<2001|year>2017) stop("year: no data available")

  if(year == 2017) dt <- RSwissMaps::mapCH2017
  if(year == 2016) dt <- RSwissMaps::mapCH2016
  if(year == 2015) dt <- RSwissMaps::mapCH2015
  if(year == 2014) dt <- RSwissMaps::mapCH2014
  if(year == 2013) dt <- RSwissMaps::mapCH2013
  if(year == 2012) dt <- RSwissMaps::mapCH2012
  if(year == 2011) dt <- RSwissMaps::mapCH2011
  if(year == 2010) dt <- RSwissMaps::mapCH2010
  if(year == 2009) dt <- RSwissMaps::mapCH2009
  if(year == 2008) dt <- RSwissMaps::mapCH2008
  if(year == 2007) dt <- RSwissMaps::mapCH2007
  if(year == 2006) dt <- RSwissMaps::mapCH2006
  if(year == 2005) dt <- RSwissMaps::mapCH2005
  if(year == 2004) dt <- RSwissMaps::mapCH2004
  if(year == 2003) dt <- RSwissMaps::mapCH2003
  if(year == 2002) dt <- RSwissMaps::mapCH2002
  if(year == 2001) dt <- RSwissMaps::mapCH2001

  if(endofyear == TRUE){

      data_map <- dt[dt$year==year&dt$type=="municipality"&dt$endofyear==1,]
      data_country <- dt[dt$year==year&dt$type=="country"&dt$endofyear==1,]
      data_cantons <- dt[dt$year==year&dt$type=="canton"&dt$endofyear==1,]
      data_districts <- dt[dt$year==year&dt$type=="district"&dt$endofyear==1,]
      data_municipalities <- dt[dt$year==year&dt$type=="municipality"&dt$endofyear==1,]
      data_lakes <- dt[dt$year==year&dt$type=="lake"&dt$endofyear==1,]

      if(nrow(data_map)==0){

        data_map <- dt[dt$year==year&dt$type=="municipality"&dt$endofyear==0,]
        message(paste0("no data found for endofyear = TRUE; automatically applied endofyear = FALSE; map dates from 01.01.", year))

      }

      if(nrow(data_country)==0) data_country <- dt[dt$year==year&dt$type=="country"&dt$endofyear==0,]
      if(nrow(data_cantons)==0) data_cantons <- dt[dt$year==year&dt$type=="canton"&dt$endofyear==0,]
      if(nrow(data_districts)==0) data_districts <- dt[dt$year==year&dt$type=="district"&dt$endofyear==0,]
      if(nrow(data_municipalities)==0) data_municipalities <- dt[dt$year==year&dt$type=="municipality"&dt$endofyear==0,]
      if(nrow(data_lakes)==0) data_lakes <- dt[dt$year==year&dt$type=="lake"&dt$endofyear==0,]


      } else {

        data_map <- dt[dt$year==year&dt$type=="municipality"&dt$endofyear==0,]
        data_country <- dt[dt$year==year&dt$type=="country"&dt$endofyear==0,]
        data_cantons <- dt[dt$year==year&dt$type=="canton"&dt$endofyear==0,]
        data_districts <- dt[dt$year==year&dt$type=="district"&dt$endofyear==0,]
        data_municipalities <- dt[dt$year==year&dt$type=="municipality"&dt$endofyear==0,]
        data_lakes <- dt[dt$year==year&dt$type=="lake"&dt$endofyear==0,]

      }

  # Merge input data with map data ------------------------
  data_bfs <- cbind.data.frame(bfs_id, data)
  names(data_bfs) <- c("id", "data")
  data_combined <-  dplyr::left_join(data_map, data_bfs, by = c("id" = "id"))

  # Apply CANTONS on pre-loaded map data ------------------------
  data_combined_c <- NULL
  districts_boundary <- NULL

  if(!is.null(cantons)){

    cantons_name <- unique(data_cantons$name)
    cantons_id <- unique(data_cantons$id)
    cantons_boundary <- NULL

    if(!is.numeric(cantons)){

      # checking non-numeric input
      wrong_cantons <- setdiff(tolower(cantons), tolower(cantons_name))
      if(length(wrong_cantons) > 0) stop(paste0("unknown canton: ", wrong_cantons, collapse = ", "))

      # building map data
      for(i in 1:length(cantons_name)){
        if(length(intersect(tolower(cantons_name[i]), tolower(cantons))) > 0) data_combined_c <- rbind.data.frame(data_combined_c, data_combined[data_combined$can==cantons_id[i],])
        if(length(intersect(tolower(cantons_name[i]), tolower(cantons))) > 0) cantons_boundary <- rbind.data.frame(cantons_boundary, data_cantons[data_cantons$id==cantons_id[i],])
        if(length(intersect(tolower(cantons_name[i]), tolower(cantons))) > 0) districts_boundary <- rbind.data.frame(districts_boundary, data_districts[data_districts$can==cantons_id[i],])

      }

    }
    if(is.numeric(cantons)){

      # checking numeric input
      wrong_cantons <- setdiff(cantons, cantons_id)
      if(length(wrong_cantons) > 0) stop(paste0("unknown canton id: ", wrong_cantons, collapse = ", "))

      # building map data
      for(i in 1:length(cantons_id)){
        if(length(intersect(cantons_id[i], cantons)) > 0) data_combined_c <- rbind.data.frame(data_combined_c, data_combined[data_combined$can==cantons_id[i],])
        if(length(intersect(cantons_id[i], cantons)) > 0) cantons_boundary <- rbind.data.frame(cantons_boundary, data_cantons[data_cantons$id==cantons_id[i],])
        if(length(intersect(cantons_id[i], cantons)) > 0) districts_boundary <- rbind.data.frame(districts_boundary, data_districts[data_districts$can==cantons_id[i],])

      }

    }

    rm(cantons_name, cantons_id)

  }
  # Apply DISTRICTS on pre-loaded map data ------------------------
  data_combined_d <- NULL

  if(!is.null(districts)){

    districts_name <- unique(data_districts$name)
    districts_id <- unique(data_districts$id)

    if(!is.numeric(districts)){

      # checking non-numeric input
      wrong_districts <- setdiff(tolower(districts), tolower(districts_name))
      if(length(wrong_districts) > 1) stop(paste0("unknown district: ", wrong_districts, collapse = ", "))

      # building map data
      for(i in 1:length(districts_name)){
        if(length(intersect(tolower(districts_name[i]), tolower(districts))) > 0) data_combined_d <- rbind.data.frame(data_combined_d, data_combined[data_combined$dis==districts_id[i],])
        if(length(intersect(tolower(districts_name[i]), tolower(districts))) > 0) districts_boundary <- rbind.data.frame(districts_boundary, data_districts[data_districts$id==districts_id[i],])
      }

    }
    if(is.numeric(districts)){

      # checking numeric input
      wrong_districts <- setdiff(districts, districts_id)
      if(length(wrong_districts) > 1) stop(paste0("unknown district: ", wrong_districts, collapse = ", "))

      # building map data
      for(i in 1:length(districts_id)){
        if(length(intersect(districts_id[i], districts)) > 0) data_combined_d <- rbind.data.frame(data_combined_d, data_combined[data_combined$dis==districts_id[i],])
        if(length(intersect(districts_id[i], districts)) > 0) districts_boundary <- rbind.data.frame(districts_boundary, data_districts[data_districts$id==districts_id[i],])

      }

    }

    rm(districts_name, districts_id)

  }
  # Apply MUNICIPALITY on pre-loaded map data ------------------------
  data_combined_m <- NULL

  if(!is.null(municipalities)){

    municipalities_name <- unique(data_municipalities$name)
    municipalities_id <- unique(data_municipalities$id)
    municipalities_boundary <- NULL

    if(!is.numeric(municipalities)){

      # checking non-numeric input
      wrong_municipalities <- setdiff(tolower(municipalities), tolower(municipalities_name))
      if(length(wrong_municipalities) == 1) stop(paste0("unknown municipality: ", wrong_municipalities, collapse = ", "))

      # building map data
      for(i in 1:length(municipalities_name)){
        if(length(intersect(tolower(municipalities_name[i]), tolower(municipalities))) > 0) data_combined_m <- rbind.data.frame(data_combined_m, data_combined[data_combined$id==municipalities_id[i],])
        if(length(intersect(tolower(municipalities_name[i]), tolower(municipalities))) > 0) municipalities_boundary <- rbind.data.frame(municipalities_boundary, data_combined[data_combined$id==municipalities_id[i],])
      }

    }
    if(is.numeric(municipalities)){

      # checking numeric input
      wrong_municipalities <- setdiff(municipalities, municipalities_id)
      if(length(wrong_municipalities) == 1) stop(paste0("unknown municipality: ", wrong_municipalities, collapse = ", "))

      # building map data
      for(i in 1:length(municipalities_id)){
        if(length(intersect(municipalities_id[i], municipalities)) > 0) data_combined_m <- rbind.data.frame(data_combined_m, data_combined[data_combined$id==municipalities_id[i],])
        if(length(intersect(municipalities_id[i], municipalities)) > 0) municipalities_boundary <- rbind.data.frame(municipalities_boundary, data_combined[data_combined$id==municipalities_id[i],])

      }

    }

    rm(municipalities_name, municipalities_id)

  }
  # joining CANTONS, DISTRICTS and MUNICIPALITY ------------------------
  if(!is.null(data_combined_c) | !is.null(data_combined_d) | !is.null(data_combined_m)){

    if(continuous == FALSE){

    long <- c(data_combined_c$long, data_combined_d$long, data_combined_m$long)
    lat <- c(data_combined_c$lat, data_combined_d$lat, data_combined_m$lat)
    group <- c(data_combined_c$group, data_combined_d$group, data_combined_m$group)
    data <- c(as.character(data_combined_c$data), as.character(data_combined_d$data), as.character(data_combined_m$data))
    data_combined <- cbind.data.frame(long, lat, group, data)
    data_combined$data <- as.factor(data_combined$data)
    data_combined$id2 <- paste0(data_combined$long, "-", data_combined$lat, "-", data_combined$group)
    data_combined <- data_combined[!duplicated(data_combined$id),]
    data_combined$id2 <- NULL

    } else {

      long <- c(data_combined_c$long, data_combined_d$long, data_combined_m$long)
      lat <- c(data_combined_c$lat, data_combined_d$lat, data_combined_m$lat)
      group <- c(data_combined_c$group, data_combined_d$group, data_combined_m$group)
      data <- c(data_combined_c$data, data_combined_d$data, data_combined_m$data)
      data_combined <- cbind.data.frame(long, lat, group, data)
      data_combined$id2 <- paste0(data_combined$long, "-", data_combined$lat, "-", data_combined$group)
      data_combined <- data_combined[!duplicated(data_combined$id),]
      data_combined$id2 <- NULL

    }
  }

  # Apply LAKES on pre-loaded map data ------------------------
  lakes_l <- tolower(lakes[1])

  if(lakes_l != "none"&lakes_l != "all"){

    lakes_name <- unique(data_lakes$name)
    lakes_id <- unique(data_lakes$id)
    data_lakes_s <- NULL

    if(!is.numeric(lakes)){

      # checking non-numeric input
      wrong_lakes <- setdiff(tolower(lakes), tolower(lakes_name))
      if(length(wrong_lakes) > 0) stop(paste0("unknown lake: ", wrong_lakes, collapse = ", "))

      # building lake map data
      for(i in 1:length(lakes_name)){
        if(length(intersect(tolower(lakes_name[i]), tolower(lakes))) > 0) data_lakes_s <- rbind.data.frame(data_lakes_s, data_lakes[data_lakes$id==lakes_id[i],])
      }

    }
    if(is.numeric(lakes)){

      # checking numeric input
      wrong_lakes <- setdiff(lakes, lakes_id)
      if(length(wrong_lakes) > 0) stop(paste0("unknown lake: ", wrong_lakes, collapse = ", "))

      # building lake map data
      for(i in 1:length(lakes_id)){
        if(length(intersect(lakes_id[i], lakes)) > 0) data_lakes_s <- rbind.data.frame(data_lakes_s, data_lakes[data_lakes$id==lakes_id[i],])
      }

    }

    data_lakes <- data_lakes_s
    rm(data_lakes_s, lakes_name, lakes_id)

  }

  # Apply EXTREMA ------------------------
  if(extrema != "global" & extrema != "local") stop("extrema: unknown input")

  if(extrema == "global" & continuous == TRUE){

    if(!is.null(data_combined_c) | !is.null(data_combined_d) | !is.null(data_combined_m)){

      data_combined <- rbind.data.frame(data_combined, data_combined[nrow(data_combined),])
      data_combined <- rbind.data.frame(data_combined, data_combined[nrow(data_combined),])

      data_combined$data[nrow(data_combined)-1] <- min(data_bfs$data)
      data_combined$long[nrow(data_combined)-1] <- NA
      data_combined$lat[nrow(data_combined)-1] <- NA
      data_combined$group[nrow(data_combined)-1] <- NA
      data_combined$data[nrow(data_combined)] <- max(data_bfs$data)
      data_combined$long[nrow(data_combined)] <- NA
      data_combined$lat[nrow(data_combined)] <- NA
      data_combined$group[nrow(data_combined)] <- NA

    }
  }

  rm(data_combined_c, data_combined_d, data_combined_m, data_bfs)

  # Plot areas ------------------------
  if(!is.logical(continuous)) stop("continuous: TRUE or FALSE needed")

  if(continuous == FALSE){

    p <- ggplot2::ggplot() +

      ggplot2::geom_polygon(data = data_combined, ggplot2::aes(fill = data_combined$data, x = long, y = lat, group = group)) +

      ggplot2::coord_equal() +

      ggplot2::theme_minimal() +

      ggplot2::theme(
        axis.line = ggplot2::element_blank(),
        axis.text.x = ggplot2::element_blank(),
        axis.text.y = ggplot2::element_blank(),
        axis.ticks = ggplot2::element_blank(),
        axis.title.x = ggplot2::element_blank(),
        axis.title.y = ggplot2::element_blank(),
        panel.grid.major = ggplot2::element_blank(),
        panel.grid.minor = ggplot2::element_blank(),
        plot.background = ggplot2::element_blank(),
        panel.background = ggplot2::element_blank(),
        legend.background = ggplot2::element_blank(),
        panel.border = ggplot2::element_blank(),
        legend.position = legend_position) +

      ggplot2::labs(x = NULL,
           y = NULL,
           title = title,
           subtitle = subtitle,
           caption = caption) +

      ggplot2::scale_fill_brewer(
        type = color_discrete[1],
        palette = as.numeric(color_discrete[2]),
        na.value = color_na,
        name = legend_title,
        guide = ggplot2::guide_legend(
          keyheight = ggplot2::unit(5, units = "mm"),
          title.position = 'top',
          reverse = T
        ))

  } else {

      p <- ggplot2::ggplot() +

        ggplot2::geom_polygon(data = data_combined, ggplot2::aes(fill = data_combined$data, x = long, y = lat, group = group)) +

        ggplot2::coord_equal() +

        ggplot2::theme_minimal() +

        ggplot2::theme(
          axis.line = ggplot2::element_blank(),
          axis.text.x = ggplot2::element_blank(),
          axis.text.y = ggplot2::element_blank(),
          axis.ticks = ggplot2::element_blank(),
          axis.title.x = ggplot2::element_blank(),
          axis.title.y = ggplot2::element_blank(),
          panel.grid.major = ggplot2::element_blank(),
          panel.grid.minor = ggplot2::element_blank(),
          plot.background = ggplot2::element_blank(),
          panel.background = ggplot2::element_blank(),
          legend.background = ggplot2::element_blank(),
          panel.border = ggplot2::element_blank(),
          legend.position = "bottom"
        ) +

        ggplot2::labs(x = NULL,
             y = NULL,
             title = title,
             subtitle = subtitle,
             caption = caption) +

        ggplot2::scale_fill_gradient(
          low = color_continuous[1],
          high = color_continuous[2],
          na.value = color_na,
          name = legend_title,
          guide = ggplot2::guide_colorbar(
            direction = "horizontal",
            barheight = ggplot2::unit(2, units = "mm"),
            barwidth = ggplot2::unit(50, units = "mm"),
            draw.ulim = FALSE,
            title.position = 'top',
            title.hjust = 0.5,
            label.hjust = 0.5))

    }
  # Add boundaries to plot ------------------------
  if(length(boundaries)!=length(boundaries_size) | length(boundaries)!=length(boundaries_color)) stop("boundary settings are not correctly specified")

  if(!is.null(boundaries)){
  # boundaries municipalities
  if("m" %in% boundaries == TRUE){
    p <- p + ggplot2::geom_path(data = data_combined, ggplot2::aes(x = long, y = lat, group = group), color = boundaries_color[which(boundaries == "m")], size = boundaries_size[which(boundaries == "m")])
  }

  # boundaries districts
  if("d" %in% boundaries == TRUE){

    if(!missing(districts)){
      p <- p + ggplot2::geom_path(data = districts_boundary, ggplot2::aes(x = long, y = lat, group = group), color = boundaries_color[which(boundaries == "d")], size = boundaries_size[which(boundaries == "d")])
    } else {
      p <- p + ggplot2::geom_path(data = data_districts, ggplot2::aes(x = long, y = lat, group = group), color = boundaries_color[which(boundaries == "d")], size = boundaries_size[which(boundaries == "d")])
    }
  }

  # boundaries cantons
  if("c" %in% boundaries == TRUE){
    if(!missing(cantons)){
      p <- p + ggplot2::geom_path(data = cantons_boundary, ggplot2::aes(x = long, y = lat, group = group), color = boundaries_color[which(boundaries == "c")], size = boundaries_size[which(boundaries == "c")])
    } else {
      p <- p + ggplot2::geom_path(data = data_cantons, ggplot2::aes(x = long, y = lat, group = group), color = boundaries_color[which(boundaries == "c")], size = boundaries_size[which(boundaries == "c")])
    }
  }

  # boundary country
  if("n" %in% boundaries == TRUE){
    p <- p + ggplot2::geom_path(data = data_country, ggplot2::aes(x = long, y = lat, group = group), color = boundaries_color[which(boundaries == "n")], size = boundaries_size[which(boundaries == "n")])
  }
  }

  # Add LAKES to plot ------------------------
  if(lakes[1] != "none"){
    p <- p +

      # Lakes
      ggplot2::geom_polygon(data = data_lakes, ggplot2::aes(x = long, y = lat, group = group), fill = "skyblue") +

      # Lakes (boarders)
      ggplot2::geom_path(data = data_lakes, ggplot2::aes(x = long, y = lat, group = group), color = "white", size = 0.1)

  }

  # Saving plot ------------------------
  if(save == TRUE){
    ggplot2::ggsave(paste0(filename), dpi = dpi, width = width, height = heigth, units = units)
  }

  rm(dt)
  p

}

# FUNCTION TO PLOT DISTRICTS
#' Plot thematic district-level maps
#'
#' \code{dis.plot} offers the possbility to visualise Swiss district-level data on a map. The GitHub version
#'     of \code{RSwissMaps} comes with all available geodata (\code{2001-2017}). Hence, the \code{map.load} function
#'     is not part of this version. The function arguments make it easy to plot and save customised maps. The function
#'     \code{\link{mun.template}} provides templates for data collection.
#'
#' @param bfs_id a numeric vector with district identification numbers as used by the Swiss Federal
#'     Statistical Office corresponding to \code{data}. For templates, see: \code{\link{dis.template}}.
#' @param data a vector of data at district-level.
#' @param year a numeric value that indicates what map version to plot. Available with GitHub version of
#'     package: \code{2001-2017}.
#' @param endofyear if \code{FALSE}, administrative divisions as of January 1 are used. If \code{TRUE},
#'     administrative divisions as by December 31 are plotted. End-of-year data is available for
#'     \code{year > 2010}.
#' @param cantons a numeric (canton identification numbers) or a character (two-letter abbreviations)
#'     vector to plot districts of selected cantons.
#' @param districts a numeric (district identification numbers) or a character (district names) vector
#'     to plot selected districts.
#' @param lakes a numeric (lake identification numbers) or a character (lakes names) vector to
#'     plot selected lakes. If \code{"none"}, no lakes are plotted. If \code{"all"}, all
#'     \href{https://github.com/zumbov2/RSwissMaps/blob/master/lakes}{available lakes} are plotted.
#' @param boundaries a character vector naming the boundaries to map:\itemize{
#'   \item \code{"d"}: district boundaries (default)
#'   \item \code{"c"}: cantonal boundaries
#'   \item \code{"n"}: national boundary}
#' @param boundaries_size a numeric vector that specifies the sizes of the corresponding elements in \code{boundaries}.
#' @param boundaries_color a character vector that specifies the colors of the corresponding elements
#'     in \code{boundaries}.
#' @param extrema if \code{"local"}, data of districts that are not selected by \code{cantons} and/or
#'     \code{districts} is not considered in the color scaling process.
#' @param continuous set to \code{FALSE}, if \code{data} is non-continuous.
#' @param color_continuous a character vector with two elements to specifiy the plot color if \code{continuous =
#'     TRUE}. \code{color_continuous = c("low", "high")} resulting in a two color gradient from color
#'     \code{"low"} to color \code{"high"}.
#' @param color_discrete name of a RColorBrewer palette to specifiy the plot color if \code{continuous = FALSE}.
#'     See: \href{https://rpubs.com/flowertear/224344 }{RColorBrewer palettes}.
#' @param color_na a character string. color of districts with missing values.
#' @param title,subtitle,caption,legend_title text for titles and caption below the plot.
#' @param legend_position position of the legend: one of \code{"none"}, \code{"left"}, \code{"right"},
#'     \code{"bottom"}, \code{"top"})
#' @param save if \code{TRUE}, the map will be saved to disk.
#' @param filename file name to create on disk incl. image file format (".jpeg", ".png", ".tiff", etc.).
#' @param dpi plot resolution. Applies only to raster output types.
#' @param width,heigth,units plot size in units (\code{"in"}, \code{"cm"}, or \code{"mm"}). If not supplied, uses
#'     the size of current graphics device.
#' @examples
#'  # Generating sample data for 2016:
#'  dt <- dis.template(2016)
#'  for(i in 1:nrow(dt)){dt$values[i] <- sample(c(300:700), 1)/1000}
#'
#'  # Plotting sample data of 2016:
#'  dis.plot(dt$bfs_nr, dt$values, 2016)
#'
#'  # Plotting sample data for the canton of Aargau:
#'  dis.plot(dt$bfs_nr, dt$values, cantons = c("AG"), 2016,
#'  lakes = c("Hallwilersee"))
#' @export
dis.plot <- function(bfs_id, data, year, endofyear = FALSE,
                     cantons = NULL, districts = NULL, lakes = "all",
                     boundaries = "d", boundaries_size = 0.1, boundaries_color = "white",
                     extrema = "global", continuous = TRUE,
                     color_continuous = c("#fee5d9", "#a50f15"), color_discrete = c("Reds"), color_na = "gray90",
                     title = NULL, subtitle = NULL, caption = NULL, legend_title = NULL, legend_position = "bottom",
                     save = FALSE, filename = "dis_plot.png", dpi = 300, width = NA, heigth = NA, units = "cm") {

  # Checking BFS_ID and data ------------------------
  if(missing(bfs_id)) stop("bfs_id is missing")
  if(missing(data)) stop("data is missing")
  if(length(bfs_id)!=length(data)) stop("inputs differ in length")

  # Loading map data based on YEAR and ENDOFYEAR ------------------------
  if(!is.logical(endofyear)) stop("endofyear: TRUE or FALSE needed")
  if(year<2001|year>2017) stop("year: no data available")

  if(year == 2017) dt <- RSwissMaps::mapCH2017
  if(year == 2016) dt <- RSwissMaps::mapCH2016
  if(year == 2015) dt <- RSwissMaps::mapCH2015
  if(year == 2014) dt <- RSwissMaps::mapCH2014
  if(year == 2013) dt <- RSwissMaps::mapCH2013
  if(year == 2012) dt <- RSwissMaps::mapCH2012
  if(year == 2011) dt <- RSwissMaps::mapCH2011
  if(year == 2010) dt <- RSwissMaps::mapCH2010
  if(year == 2009) dt <- RSwissMaps::mapCH2009
  if(year == 2008) dt <- RSwissMaps::mapCH2008
  if(year == 2007) dt <- RSwissMaps::mapCH2007
  if(year == 2006) dt <- RSwissMaps::mapCH2006
  if(year == 2005) dt <- RSwissMaps::mapCH2005
  if(year == 2004) dt <- RSwissMaps::mapCH2004
  if(year == 2003) dt <- RSwissMaps::mapCH2003
  if(year == 2002) dt <- RSwissMaps::mapCH2002
  if(year == 2001) dt <- RSwissMaps::mapCH2001

  if(endofyear == TRUE){

    data_map <- dt[dt$year==year&dt$type=="district"&dt$endofyear==1,]
    data_country <- dt[dt$year==year&dt$type=="country"&dt$endofyear==1,]
    data_cantons <- dt[dt$year==year&dt$type=="canton"&dt$endofyear==1,]
    data_districts <- dt[dt$year==year&dt$type=="district"&dt$endofyear==1,]
    data_lakes <- dt[dt$year==year&dt$type=="lake"&dt$endofyear==1,]

    if(nrow(data_map)==0){

      data_map <- dt[dt$year==year&dt$type=="district"&dt$endofyear==0,]
      message(paste0("no data found for endofyear = TRUE; automatically applied endofyear = FALSE; map dates from 01.01.", year))

    }

    if(nrow(data_country)==0) data_country <- dt[dt$year==year&dt$type=="country"&dt$endofyear==0,]
    if(nrow(data_cantons)==0) data_cantons <- dt[dt$year==year&dt$type=="canton"&dt$endofyear==0,]
    if(nrow(data_districts)==0) data_districts <- dt[dt$year==year&dt$type=="district"&dt$endofyear==0,]
    if(nrow(data_lakes)==0) data_lakes <- dt[dt$year==year&dt$type=="lake"&dt$endofyear==0,]


  } else {

    data_map <- dt[dt$year==year&dt$type=="district"&dt$endofyear==0,]
    data_country <- dt[dt$year==year&dt$type=="country"&dt$endofyear==0,]
    data_cantons <- dt[dt$year==year&dt$type=="canton"&dt$endofyear==0,]
    data_districts <- dt[dt$year==year&dt$type=="district"&dt$endofyear==0,]
    data_lakes <- dt[dt$year==year&dt$type=="lake"&dt$endofyear==0,]

  }

  # Merge input data with map data ------------------------
  data_bfs <- cbind.data.frame(bfs_id, data)
  names(data_bfs) <- c("id", "data")
  data_combined <- dplyr::left_join(data_map, data_bfs, by = c("id" = "id"))

  # Apply CANTONS on pre-loaded map data ------------------------
  data_combined_c <- NULL

  if(!is.null(cantons)){

    cantons_name <- unique(data_cantons$name)
    cantons_id <- unique(data_cantons$id)
    cantons_boundary <- NULL

    if(!is.numeric(cantons)){

      # checking non-numeric input
      wrong_cantons <- setdiff(tolower(cantons), tolower(cantons_name))
      if(length(wrong_cantons) > 0) stop(paste0("unknown canton: ", wrong_cantons, collapse = ", "))

      # building map data
      for(i in 1:length(cantons_name)){
        if(length(intersect(tolower(cantons_name[i]), tolower(cantons))) > 0) data_combined_c <- rbind.data.frame(data_combined_c, data_combined[data_combined$can==cantons_id[i],])
        if(length(intersect(tolower(cantons_name[i]), tolower(cantons))) > 0) cantons_boundary <- rbind.data.frame(cantons_boundary, data_cantons[data_cantons$id==cantons_id[i],])

      }

    }
    if(is.numeric(cantons)){

      # checking numeric input
      wrong_cantons <- setdiff(cantons, cantons_id)
      if(length(wrong_cantons) > 0) stop(paste0("unknown canton id: ", wrong_cantons, collapse = ", "))

      # building map data
      for(i in 1:length(cantons_id)){
        if(length(intersect(cantons_id[i], cantons)) > 0) data_combined_c <- rbind.data.frame(data_combined_c, data_combined[data_combined$can==cantons_id[i],])
        if(length(intersect(cantons_id[i], cantons)) > 0) cantons_boundary <- rbind.data.frame(cantons_boundary, data_cantons[data_cantons$id==cantons_id[i],])

      }

    }

    rm(cantons_name, cantons_id)

  }
  # Apply DISTRICTS on pre-loaded map data ------------------------
  data_combined_d <- NULL

  if(!is.null(districts)){

    districts_name <- unique(data_districts$name)
    districts_id <- unique(data_districts$id)
    districts_boundary <- NULL

    if(!is.numeric(districts)){

      # checking non-numeric input
      wrong_districts <- setdiff(tolower(districts), tolower(districts_name))
      if(length(wrong_districts) > 1) stop(paste0("unknown district: ", wrong_districts, collapse = ", "))

      # building map data
      for(i in 1:length(districts_name)){
        if(length(intersect(tolower(districts_name[i]), tolower(districts))) > 0) data_combined_d <- rbind.data.frame(data_combined_d, data_combined[data_combined$id==districts_id[i],])
        if(length(intersect(tolower(districts_name[i]), tolower(districts))) > 0) districts_boundary <- rbind.data.frame(districts_boundary, data_districts[data_districts$id==districts_id[i],])
      }

    }
    if(is.numeric(districts)){

      # checking numeric input
      wrong_districts <- setdiff(districts, districts_id)
      if(length(wrong_districts) > 1) stop(paste0("unknown district: ", wrong_districts, collapse = ", "))

      # building map data
      for(i in 1:length(districts_id)){
        if(length(intersect(districts_id[i], districts)) > 0) data_combined_d <- rbind.data.frame(data_combined_d, data_combined[data_combined$id==districts_id[i],])
        if(length(intersect(districts_id[i], districts)) > 0) districts_boundary <- rbind.data.frame(districts_boundary, data_districts[data_districts$id==districts_id[i],])

      }

    }

    rm(districts_name, districts_id)

  }
  # joining CANTONS and DISTRICTS ------------------------
  if(!is.null(data_combined_c) | !is.null(data_combined_d)){

    if(continuous == FALSE){

      long <- c(data_combined_c$long, data_combined_d$long)
      lat <- c(data_combined_c$lat, data_combined_d$lat)
      group <- c(data_combined_c$group, data_combined_d$group)
      data <- c(as.character(data_combined_c$data), as.character(data_combined_d$data))
      data_combined <- cbind.data.frame(long, lat, group, data)
      data_combined$data <- as.factor(data_combined$data)
      data_combined$id2 <- paste0(data_combined$long, "-", data_combined$lat, "-", data_combined$group)
      data_combined <- data_combined[!duplicated(data_combined$id),]
      data_combined$id2 <- NULL

    } else {

      long <- c(data_combined_c$long, data_combined_d$long)
      lat <- c(data_combined_c$lat, data_combined_d$lat)
      group <- c(data_combined_c$group, data_combined_d$group)
      data <- c(data_combined_c$data, data_combined_d$data)
      data_combined <- cbind.data.frame(long, lat, group, data)
      data_combined$id2 <- paste0(data_combined$long, "-", data_combined$lat, "-", data_combined$group)
      data_combined <- data_combined[!duplicated(data_combined$id),]
      data_combined$id2 <- NULL

    }
  }

  # Apply LAKES on pre-loaded map data ------------------------
  lakes_l <- tolower(lakes[1])

  if(lakes_l != "none"&lakes_l != "all"){

    lakes_name <- unique(data_lakes$name)
    lakes_id <- unique(data_lakes$id)
    data_lakes_s <- NULL

    if(!is.numeric(lakes)){

      # checking non-numeric input
      wrong_lakes <- setdiff(tolower(lakes), tolower(lakes_name))
      if(length(wrong_lakes) > 0) stop(paste0("unknown lake: ", wrong_lakes, collapse = ", "))

      # building lake map data
      for(i in 1:length(lakes_name)){
        if(length(intersect(tolower(lakes_name[i]), tolower(lakes))) > 0) data_lakes_s <- rbind.data.frame(data_lakes_s, data_lakes[data_lakes$id==lakes_id[i],])
      }

    }
    if(is.numeric(lakes)){

      # checking numeric input
      wrong_lakes <- setdiff(lakes, lakes_id)
      if(length(wrong_lakes) > 0) stop(paste0("unknown lake: ", wrong_lakes, collapse = ", "))

      # building lake map data
      for(i in 1:length(lakes_id)){
        if(length(intersect(lakes_id[i], lakes)) > 0) data_lakes_s <- rbind.data.frame(data_lakes_s, data_lakes[data_lakes$id==lakes_id[i],])
      }

    }

    data_lakes <- data_lakes_s
    rm(data_lakes_s, lakes_name, lakes_id)

  }

  # Apply EXTREMA ------------------------
  if(extrema != "global" & extrema != "local") stop("extrema: unknown input")

  if(extrema == "global" & continuous == TRUE){

    if(!is.null(data_combined_c) | !is.null(data_combined_d)){

      data_combined <- rbind.data.frame(data_combined, data_combined[nrow(data_combined),])
      data_combined <- rbind.data.frame(data_combined, data_combined[nrow(data_combined),])

      data_combined$data[nrow(data_combined)-1] <- min(data_bfs$data)
      data_combined$long[nrow(data_combined)-1] <- NA
      data_combined$lat[nrow(data_combined)-1] <- NA
      data_combined$group[nrow(data_combined)-1] <- NA
      data_combined$data[nrow(data_combined)] <- max(data_bfs$data)
      data_combined$long[nrow(data_combined)] <- NA
      data_combined$lat[nrow(data_combined)] <- NA
      data_combined$group[nrow(data_combined)] <- NA

    }
  }

  rm(data_combined_c, data_combined_d, data_bfs)

  # Plot areas ------------------------
  if(!is.logical(continuous)) stop("continuous: TRUE or FALSE needed")

  if(continuous == FALSE){

    data_combined$data <- as.factor(data_combined$data)

    p <- ggplot2::ggplot() +

      ggplot2::geom_polygon(data = data_combined, ggplot2::aes(fill = data_combined$data, x = long, y = lat, group = group)) +

      ggplot2::coord_equal() +

      ggplot2::theme_minimal() +

      ggplot2::theme(
        axis.line = ggplot2::element_blank(),
        axis.text.x = ggplot2::element_blank(),
        axis.text.y = ggplot2::element_blank(),
        axis.ticks = ggplot2::element_blank(),
        axis.title.x = ggplot2::element_blank(),
        axis.title.y = ggplot2::element_blank(),
        panel.grid.major = ggplot2::element_blank(),
        panel.grid.minor = ggplot2::element_blank(),
        plot.background = ggplot2::element_blank(),
        panel.background = ggplot2::element_blank(),
        legend.background = ggplot2::element_blank(),
        panel.border = ggplot2::element_blank(),
        legend.position = legend_position) +

      ggplot2::labs(x = NULL,
           y = NULL,
           title = title,
           subtitle = subtitle,
           caption = caption) +

      ggplot2::scale_fill_brewer(
        type = color_discrete[1],
        palette = as.numeric(color_discrete[2]),
        na.value = color_na,
        name = legend_title,
        guide = ggplot2::guide_legend(
          keyheight = ggplot2::unit(5, units = "mm"),
          title.position = 'top',
          reverse = T))

  } else {

    p <- ggplot2::ggplot() +

      ggplot2::geom_polygon(data = data_combined, ggplot2::aes(fill = data_combined$data, x = long, y = lat, group = group)) +

      ggplot2::coord_equal() +

      ggplot2::theme_minimal() +

      ggplot2::theme(
        axis.line = ggplot2::element_blank(),
        axis.text.x = ggplot2::element_blank(),
        axis.text.y = ggplot2::element_blank(),
        axis.ticks = ggplot2::element_blank(),
        axis.title.x = ggplot2::element_blank(),
        axis.title.y = ggplot2::element_blank(),
        panel.grid.major = ggplot2::element_blank(),
        panel.grid.minor = ggplot2::element_blank(),
        plot.background = ggplot2::element_blank(),
        panel.background = ggplot2::element_blank(),
        legend.background = ggplot2::element_blank(),
        panel.border = ggplot2::element_blank(),
        legend.position = "bottom"
      ) +

      ggplot2::labs(x = NULL,
           y = NULL,
           title = title,
           subtitle = subtitle,
           caption = caption) +

      ggplot2::scale_fill_gradient(
        low = color_continuous[1],
        high = color_continuous[2],
        na.value = color_na,
        name = legend_title,
        guide = ggplot2::guide_colorbar(
          direction = "horizontal",
          barheight = ggplot2::unit(2, units = "mm"),
          barwidth = ggplot2::unit(50, units = "mm"),
          draw.ulim = FALSE,
          title.position = 'top',
          title.hjust = 0.5,
          label.hjust = 0.5))

  }
  # Add boundaries to plot ------------------------
  if(length(boundaries)!=length(boundaries_size) | length(boundaries)!=length(boundaries_color)) stop("boundary settings are not correctly specified")

  if(!is.null(boundaries)){
    # boundaries municipalities
    if("d" %in% boundaries == TRUE){
      p <- p + ggplot2::geom_path(data = data_combined, ggplot2::aes(x = long, y = lat, group = group), color = boundaries_color[which(boundaries == "d")], size = boundaries_size[which(boundaries == "d")])
    }

    # boundaries cantons
    if("c" %in% boundaries == TRUE){
      if(!missing(cantons)){
        p <- p + ggplot2::geom_path(data = cantons_boundary, ggplot2::aes(x = long, y = lat, group = group), color = boundaries_color[which(boundaries == "c")], size = boundaries_size[which(boundaries == "c")])
      } else {
        p <- p + ggplot2::geom_path(data = data_cantons, ggplot2::aes(x = long, y = lat, group = group), color = boundaries_color[which(boundaries == "c")], size = boundaries_size[which(boundaries == "c")])
      }
    }

    # boundary country
    if("n" %in% boundaries == TRUE){
      p <- p + ggplot2::geom_path(data = data_country, ggplot2::aes(x = long, y = lat, group = group), color = boundaries_color[which(boundaries == "n")], size = boundaries_size[which(boundaries == "n")])
    }
  }

  # Add LAKES to plot ------------------------
  if(lakes[1] != "none"){
    p <- p +

      # Lakes
      ggplot2::geom_polygon(data = data_lakes, ggplot2::aes(x = long, y = lat, group = group), fill = "skyblue") +

      # Lakes (boarders)
      ggplot2::geom_path(data = data_lakes, ggplot2::aes(x = long, y = lat, group = group), color = "white", size = 0.1)

  }

  # Saving plot ------------------------
  if(save == TRUE){
    ggplot2::ggsave(paste0(filename), dpi = dpi, width = width, height = heigth, units = units)
  }

  rm(dt)

  p

}

# FUNCTION TO PLOT CANTONS
#' Plot thematic canton-level maps
#'
#' \code{can.plot} offers the possbility to visualise Swiss canton-level data on a map. The GitHub version
#'     of \code{RSwissMaps} comes with all available geodata (\code{2001-2017}). Hence, the \code{map.load} function
#'     is not part of this version. The function arguments make it easy to plot and save customised maps. The function
#'     \code{\link{mun.template}} provides templates for data collection.
#'
#' @param bfs_id a numeric vector with canton identification numbers as used by the Swiss Federal
#'     Statistical Office corresponding to \code{data}. For templates, see: \code{\link{can.template}}.
#' @param data a vector of data at canton-level.
#' @param year a numeric value that indicates what map version to plot. Available with GitHub version of
#'     package: \code{2001-2017}.
#' @param endofyear if \code{FALSE}, administrative divisions as of January 1 are used. If \code{TRUE},
#'     administrative divisions as by December 31 are plotted. End-of-year data is available for
#'     \code{year > 2010}.
#' @param cantons a numeric (canton identification numbers) or a character (two-letter abbreviations)
#'     vector to plot selected cantons.
#' @param lakes a numeric (lake identification numbers) or a character (lakes names) vector to
#'     plot selected lakes. If \code{"none"}, no lakes are plotted. If \code{"all"}, all
#'     \href{https://github.com/zumbov2/RSwissMaps/blob/master/lakes}{available lakes} are plotted.
#' @param boundaries a character vector naming the boundaries to map:\itemize{
#'   \item \code{"c"}: cantonal boundaries (default)
#'   \item \code{"n"}: national boundary}
#' @param boundaries_size a numeric vector that specifies the sizes of the corresponding elements in \code{boundaries}.
#' @param boundaries_color a character vector that specifies the colors of the corresponding elements
#'     in \code{boundaries}.
#' @param extrema if \code{"local"}, data of cantons that are not selected by \code{cantons} is not
#'     considered in the color scaling process.
#' @param continuous set to \code{FALSE}, if \code{data} is non-continuous.
#' @param color_continuous a character vector with two elements to specifiy the plot color if \code{continuous =
#'     TRUE}. \code{color_continuous = c("low", "high")} resulting in a two color gradient from color
#'     \code{"low"} to color \code{"high"}.
#' @param color_discrete name of a RColorBrewer palette to specifiy the plot color if \code{continuous = FALSE}.
#'     See: \href{https://rpubs.com/flowertear/224344 }{RColorBrewer palettes}.
#' @param color_na character string. color of cantons with missing values.
#' @param title,subtitle,caption,legend_title text for titles and caption below the plot.
#' @param legend_position position of the legend: one of \code{"none"}, \code{"left"}, \code{"right"},
#'     \code{"bottom"}, \code{"top"})
#' @param save if \code{TRUE}, the map will be saved to disk.
#' @param filename file name to create on disk incl. image file format (".jpeg", ".png", ".tiff", etc.).
#' @param dpi plot resolution. Applies only to raster output types.
#' @param width,heigth,units plot size in units (\code{"in"}, \code{"cm"}, or \code{"mm"}). If not supplied, uses
#'     the size of current graphics device.
#' @examples
#'  # Generating sample data for 2016:
#'  dt <- can.template(2016)
#'  for(i in 1:nrow(dt)){dt$values[i] <- sample(c(300:700), 1)/1000}
#'
#'  # Plotting sample data of 2016:
#'  can.plot(dt$bfs_nr, dt$values, 2016)
#' @export
can.plot <- function(bfs_id, data, year, endofyear = FALSE,
                     cantons = NULL, lakes = "all",
                     boundaries = "c", boundaries_size = 0.1, boundaries_color = "white",
                     extrema = "global", continuous = TRUE,
                     color_continuous = c("#fee5d9", "#a50f15"), color_discrete = c("Reds"), color_na = "gray90",
                     title = NULL, subtitle = NULL, caption = NULL, legend_title = NULL, legend_position = "bottom",
                     save = FALSE, filename = "can_plot.png", dpi = 300, width = NA, heigth = NA, units = "cm") {

  # Checking BFS_ID and data ------------------------
  if(missing(bfs_id)) stop("bfs_id is missing")
  if(missing(data)) stop("data is missing")
  if(length(bfs_id)!=length(data)) stop("inputs differ in length")
  long = lat = group = NULL

  # Loading map data based on YEAR and ENDOFYEAR ------------------------
  if(!is.logical(endofyear)) stop("endofyear: TRUE or FALSE needed")
  if(year<2001|year>2017) stop("year: no data available")

  if(year == 2017) dt <- RSwissMaps::mapCH2017
  if(year == 2016) dt <- RSwissMaps::mapCH2016
  if(year == 2015) dt <- RSwissMaps::mapCH2015
  if(year == 2014) dt <- RSwissMaps::mapCH2014
  if(year == 2013) dt <- RSwissMaps::mapCH2013
  if(year == 2012) dt <- RSwissMaps::mapCH2012
  if(year == 2011) dt <- RSwissMaps::mapCH2011
  if(year == 2010) dt <- RSwissMaps::mapCH2010
  if(year == 2009) dt <- RSwissMaps::mapCH2009
  if(year == 2008) dt <- RSwissMaps::mapCH2008
  if(year == 2007) dt <- RSwissMaps::mapCH2007
  if(year == 2006) dt <- RSwissMaps::mapCH2006
  if(year == 2005) dt <- RSwissMaps::mapCH2005
  if(year == 2004) dt <- RSwissMaps::mapCH2004
  if(year == 2003) dt <- RSwissMaps::mapCH2003
  if(year == 2002) dt <- RSwissMaps::mapCH2002
  if(year == 2001) dt <- RSwissMaps::mapCH2001

  if(endofyear == TRUE){

    data_map <- dt[dt$year==year&dt$type=="canton"&dt$endofyear==1,]
    data_country <- dt[dt$year==year&dt$type=="country"&dt$endofyear==1,]
    data_cantons <- dt[dt$year==year&dt$type=="canton"&dt$endofyear==1,]
    data_lakes <- dt[dt$year==year&dt$type=="lake"&dt$endofyear==1,]

    if(nrow(data_map)==0){

      data_map <- dt[dt$year==year&dt$type=="canton"&dt$endofyear==0,]
      message(paste0("no data found for endofyear = TRUE; automatically applied endofyear = FALSE; map dates from 01.01.", year))

    }

    if(nrow(data_country)==0) data_country <- dt[dt$year==year&dt$type=="country"&dt$endofyear==0,]
    if(nrow(data_cantons)==0) data_cantons <- dt[dt$year==year&dt$type=="canton"&dt$endofyear==0,]
    if(nrow(data_lakes)==0) data_lakes <- dt[dt$year==year&dt$type=="lake"&dt$endofyear==0,]


  } else {

    data_map <- dt[dt$year==year&dt$type=="canton"&dt$endofyear==0,]
    data_country <- dt[dt$year==year&dt$type=="country"&dt$endofyear==0,]
    data_cantons <- dt[dt$year==year&dt$type=="canton"&dt$endofyear==0,]
    data_lakes <- dt[dt$year==year&dt$type=="lake"&dt$endofyear==0,]

  }

  # Merge input data with map data ------------------------
  data_bfs <- cbind.data.frame(bfs_id, data)
  names(data_bfs) <- c("id", "data")
  data_combined <- dplyr::left_join(data_map, data_bfs, by = c("id" = "id"))

  # Apply CANTONS on pre-loaded map data ------------------------
  data_combined_c <- NULL

  if(!is.null(cantons)){

    cantons_name <- unique(data_cantons$name)
    cantons_id <- unique(data_cantons$id)
    cantons_boundary <- NULL

    if(!is.numeric(cantons)){

      # checking non-numeric input
      wrong_cantons <- setdiff(tolower(cantons), tolower(cantons_name))
      if(length(wrong_cantons) > 0) stop(paste0("unknown canton: ", wrong_cantons, collapse = ", "))

      # building map data
      for(i in 1:length(cantons_name)){
        if(length(intersect(tolower(cantons_name[i]), tolower(cantons))) > 0) data_combined_c <- rbind.data.frame(data_combined_c, data_combined[data_combined$id==cantons_id[i],])
        if(length(intersect(tolower(cantons_name[i]), tolower(cantons))) > 0) cantons_boundary <- rbind.data.frame(cantons_boundary, data_cantons[data_cantons$id==cantons_id[i],])

      }

    }
    if(is.numeric(cantons)){

      # checking numeric input
      wrong_cantons <- setdiff(cantons, cantons_id)
      if(length(wrong_cantons) > 0) stop(paste0("unknown canton id: ", wrong_cantons, collapse = ", "))

      # building map data
      for(i in 1:length(cantons_id)){
        if(length(intersect(cantons_id[i], cantons)) > 0) data_combined_c <- rbind.data.frame(data_combined_c, data_combined[data_combined$id==cantons_id[i],])
        if(length(intersect(cantons_id[i], cantons)) > 0) cantons_boundary <- rbind.data.frame(cantons_boundary, data_cantons[data_cantons$id==cantons_id[i],])

      }

    }

    rm(cantons_name, cantons_id)

  }
  # preparing map based on CANTONS ------------------------
  if(!is.null(data_combined_c)){

    data_combined <- data_combined_c

  }

  # Apply LAKES on pre-loaded map data ------------------------
  lakes_l <- tolower(lakes[1])

  if(lakes_l != "none"&lakes_l != "all"){

    lakes_name <- unique(data_lakes$name)
    lakes_id <- unique(data_lakes$id)
    data_lakes_s <- NULL

    if(!is.numeric(lakes)){

      # checking non-numeric input
      wrong_lakes <- setdiff(tolower(lakes), tolower(lakes_name))
      if(length(wrong_lakes) > 0) stop(paste0("unknown lake: ", wrong_lakes, collapse = ", "))

      # building lake map data
      for(i in 1:length(lakes_name)){
        if(length(intersect(tolower(lakes_name[i]), tolower(lakes))) > 0) data_lakes_s <- rbind.data.frame(data_lakes_s, data_lakes[data_lakes$id==lakes_id[i],])
      }

    }
    if(is.numeric(lakes)){

      # checking numeric input
      wrong_lakes <- setdiff(lakes, lakes_id)
      if(length(wrong_lakes) > 0) stop(paste0("unknown lake: ", wrong_lakes, collapse = ", "))

      # building lake map data
      for(i in 1:length(lakes_id)){
        if(length(intersect(lakes_id[i], lakes)) > 0) data_lakes_s <- rbind.data.frame(data_lakes_s, data_lakes[data_lakes$id==lakes_id[i],])
      }

    }

    data_lakes <- data_lakes_s
    rm(data_lakes_s, lakes_name, lakes_id)

  }

  # Apply EXTREMA ------------------------
  if(extrema != "global" & extrema != "local") stop("extrema: unknown input")

  if(extrema == "global" & continuous == TRUE){

    if(!is.null(data_combined_c)){

      data_combined <- rbind.data.frame(data_combined, data_combined[nrow(data_combined),])
      data_combined <- rbind.data.frame(data_combined, data_combined[nrow(data_combined),])

      data_combined$data[nrow(data_combined)-1] <- min(data_bfs$data)
      data_combined$long[nrow(data_combined)-1] <- NA
      data_combined$lat[nrow(data_combined)-1] <- NA
      data_combined$group[nrow(data_combined)-1] <- NA
      data_combined$data[nrow(data_combined)] <- max(data_bfs$data)
      data_combined$long[nrow(data_combined)] <- NA
      data_combined$lat[nrow(data_combined)] <- NA
      data_combined$group[nrow(data_combined)] <- NA

    }
  }

  rm(data_combined_c, data_bfs)

  # Plot areas ------------------------
  if(!is.logical(continuous)) stop("continuous: TRUE or FALSE needed")

  data_combined_1 <- data_combined[data_combined$id < 15 | data_combined$id > 16,]
  data_combined_ai_ar <- data_combined[data_combined$id == 15 | data_combined$id == 16,]

  if(continuous == FALSE){

    p <- ggplot2::ggplot() +

      ggplot2::geom_polygon(data = data_combined_1, ggplot2::aes(fill = data_combined_1$data, x = long, y = lat, group = group)) +

      ggplot2::geom_polygon(data = data_combined_ai_ar, ggplot2::aes(fill = data_combined_ai_ar$data, x = long, y = lat, group = group)) +

      ggplot2::coord_equal() +

      ggplot2::theme_minimal() +

      ggplot2::theme(
        axis.line = ggplot2::element_blank(),
        axis.text.x = ggplot2::element_blank(),
        axis.text.y = ggplot2::element_blank(),
        axis.ticks = ggplot2::element_blank(),
        axis.title.x = ggplot2::element_blank(),
        axis.title.y = ggplot2::element_blank(),
        panel.grid.major = ggplot2::element_blank(),
        panel.grid.minor = ggplot2::element_blank(),
        plot.background = ggplot2::element_blank(),
        panel.background = ggplot2::element_blank(),
        legend.background = ggplot2::element_blank(),
        panel.border = ggplot2::element_blank(),
        legend.position = legend_position) +

      ggplot2::labs(x = NULL,
           y = NULL,
           title = title,
           subtitle = subtitle,
           caption = caption) +

      ggplot2::scale_fill_brewer(
        type = color_discrete[1],
        palette = as.numeric(color_discrete[2]),
        na.value = color_na,
        name = legend_title,
        guide = ggplot2::guide_legend(
          keyheight = ggplot2::unit(5, units = "mm"),
          title.position = 'top',
          reverse = T))

  } else {

    p <- ggplot2::ggplot() +

      ggplot2::geom_polygon(data = data_combined_1, ggplot2::aes(fill = data_combined_1$data, x = long, y = lat, group = group)) +

      ggplot2::geom_polygon(data = data_combined_ai_ar, ggplot2::aes(fill = data_combined_ai_ar$data, x = long, y = lat, group = group)) +

      ggplot2::coord_equal() +

      ggplot2::theme_minimal() +

      ggplot2::theme(
        axis.line = ggplot2::element_blank(),
        axis.text.x = ggplot2::element_blank(),
        axis.text.y = ggplot2::element_blank(),
        axis.ticks = ggplot2::element_blank(),
        axis.title.x = ggplot2::element_blank(),
        axis.title.y = ggplot2::element_blank(),
        panel.grid.major = ggplot2::element_blank(),
        panel.grid.minor = ggplot2::element_blank(),
        plot.background = ggplot2::element_blank(),
        panel.background = ggplot2::element_blank(),
        legend.background = ggplot2::element_blank(),
        panel.border = ggplot2::element_blank(),
        legend.position = "bottom"
      ) +

      ggplot2::labs(x = NULL,
           y = NULL,
           title = title,
           subtitle = subtitle,
           caption = caption) +

      ggplot2::scale_fill_gradient(
        low = color_continuous[1],
        high = color_continuous[2],
        na.value = color_na,
        name = legend_title,
        guide = ggplot2::guide_colorbar(
          direction = "horizontal",
          barheight = ggplot2::unit(2, units = "mm"),
          barwidth = ggplot2::unit(50, units = "mm"),
          draw.ulim = FALSE,
          title.position = 'top',
          title.hjust = 0.5,
          label.hjust = 0.5))

  }

  # Add boundaries to plot ------------------------
  if(length(boundaries)!=length(boundaries_size) | length(boundaries)!=length(boundaries_color)) stop("boundary settings are not correctly specified")

  if(!is.null(boundaries)){
    # boundaries municipalities
    if("d" %in% boundaries == TRUE){
      p <- p + ggplot2::geom_path(data = data_combined, ggplot2::aes(x = long, y = lat, group = group), color = boundaries_color[which(boundaries == "d")], size = boundaries_size[which(boundaries == "d")])
    }

    # boundaries cantons
    if("c" %in% boundaries == TRUE){
      if(!missing(cantons)){
        p <- p + ggplot2::geom_path(data = cantons_boundary, ggplot2::aes(x = long, y = lat, group = group), color = boundaries_color[which(boundaries == "c")], size = boundaries_size[which(boundaries == "c")])
      } else {
        p <- p + ggplot2::geom_path(data = data_cantons, ggplot2::aes(x = long, y = lat, group = group), color = boundaries_color[which(boundaries == "c")], size = boundaries_size[which(boundaries == "c")])
      }
    }

    # boundary country
    if("n" %in% boundaries == TRUE){
      p <- p + ggplot2::geom_path(data = data_country, ggplot2::aes(x = long, y = lat, group = group), color = boundaries_color[which(boundaries == "n")], size = boundaries_size[which(boundaries == "n")])
    }
  }

  # Add LAKES to plot ------------------------
  if(lakes[1] != "none"){
    p <- p +

      # Lakes
      ggplot2::geom_polygon(data = data_lakes, ggplot2::aes(x = long, y = lat, group = group), fill = "skyblue") +

      # Lakes (boarders)
      ggplot2::geom_path(data = data_lakes, ggplot2::aes(x = long, y = lat, group = group), color = "white", size = 0.1)

  }

  # Saving plot ------------------------
  if(save == TRUE){
    ggplot2::ggsave(paste0(filename), dpi = dpi, width = width, height = heigth, units = units)
  }

  rm(dt)
  p

}
